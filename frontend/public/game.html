<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Jumping Orbits — Flow (Inward) • Clean</title>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#061a66; }
    #wrap { height:100%; display:flex; align-items:center; justify-content:center; }
    #game{
      width:min(820px, 96vw);
      height:min(820px, 96vw);
      max-height: 92vh;
      border-radius: 18px;
      overflow:hidden;
      box-shadow: 0 24px 70px rgba(0,0,0,.45);
      border:1px solid rgba(255,255,255,.10);
      background: #061a66;
    }
    .note{
      position:fixed; left:50%; transform:translateX(-50%);
      bottom:14px;
      font: 13px system-ui,-apple-system,Segoe UI,Roboto,Arial;
      color: rgba(255,255,255,.78);
      background: rgba(0,0,0,.28);
      border: 1px solid rgba(255,255,255,.10);
      padding: 10px 12px; border-radius: 14px;
      backdrop-filter: blur(10px);
      max-width: 92vw; text-align:center;
      user-select:none;
    }
    .note b{ color:#fff; }
  </style>
</head>
<body>
  <div id="wrap"><div id="game"></div></div>
  <div class="note">
    <b>Click</b>/<b>Space</b> → Jump Inward • <b>R</b> → Restart
  </div>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
  <script>
    function lerp(a,b,t){ return a+(b-a)*t; }
    function rgbToInt(r,g,b){ return (r<<16) | (g<<8) | b; }
    function hslToRgb(h,s,l){
      h /= 360;
      const hue2rgb = (p,q,t)=>{
        if(t<0) t+=1; if(t>1) t-=1;
        if(t<1/6) return p+(q-p)*6*t;
        if(t<1/2) return q;
        if(t<2/3) return p+(q-p)*(2/3-t)*6;
        return p;
      };
      let r,g,b;
      if(s===0){ r=g=b=l; }
      else{
        const q = l < 0.5 ? l*(1+s) : l+s-l*s;
        const p = 2*l-q;
        r = hue2rgb(p,q,h+1/3);
        g = hue2rgb(p,q,h);
        b = hue2rgb(p,q,h-1/3);
      }
      return [Math.round(r*255),Math.round(g*255),Math.round(b*255)];
    }

    class FlowScene extends Phaser.Scene {
      constructor(){ super("Flow"); }

      create(){
        const w = this.scale.width, h = this.scale.height;
        this.cx = w/2; this.cy = h/2 + 10;

        // THEME
        this.themeStep = 0;
        this.bgRect = this.add.rectangle(w/2,h/2,w,h, 0x061a66).setDepth(-10);

        // BEST SCORE (session-only; resets when tab closes)
        this.bestScore = Number(sessionStorage.getItem("jo_best_score") || "0");

        // UI
        this.score = 0;
        this.scoreText = this.add.text(w/2, 18, "Score: 0", {
          fontFamily:"system-ui,-apple-system,Segoe UI,Roboto,Arial",
          fontSize:"34px", color:"#fff", fontStyle:"900"
        }).setOrigin(0.5,0);

        // Best score (top-right) — nicer pill
        this.bestText = this.add.text(w - 18, 22, "BEST  " + this.bestScore, {
          fontFamily:"system-ui,-apple-system,Segoe UI,Roboto,Arial",
          fontSize:"14px",
          color:"#ffffff",
          fontStyle:"900",
          backgroundColor:"rgba(0,0,0,.28)",
          padding:{ left:12, right:12, top:8, bottom:8 }
        }).setOrigin(1,0).setAlpha(0.92);
        this.bestText.setShadow(0, 6, "rgba(0,0,0,.35)", 10, false, true);

        this.hint = this.add.text(w/2, h/2, "Click / Space to jump inward.\nAvoid red obstacles.", {
          fontFamily:"system-ui,-apple-system,Segoe UI,Roboto,Arial",
          fontSize: Math.round(Math.min(w,h)*0.055)+"px",
          color:"#fff", align:"center", fontStyle:"900"
        }).setOrigin(0.5);

        // GAME PARAMS
        this.jumpDuration = 260;

        // === REALISTIC COLLISION (pixel-based) ===
        this.playerRadius = 8;
        this.obstacleRadius = 6;
        this.collisionPad = 1.5;

        // PERFECT proximity window (pixels above collision threshold)
        // "çarpmıyor ama çok yakın" => perfect
        this.perfectNearLo = 2;   // thresh + 2px
        this.perfectNearHi = 16;  // thresh + 16px

        // SAFE radii
        this.ringCount = 7;
        const margin = Math.max(34, Math.min(w,h)*0.06);
        this.outerR = Math.min(w,h)/2 - margin;
        this.baseR  = this.outerR * 0.18;
        this.gapR   = (this.outerR - this.baseR) / (this.ringCount - 1);

        // PLAYER
        this.player = this.add.circle(0,0, this.playerRadius, 0xffffff);
        this.playerHalo = this.add.circle(0,0, 16, 0xffffff, 0.12);
        this.playerCore = this.add.circle(0,0, 4, 0xffffff, 0.95);

        // DRAW
        this.gfx = this.add.graphics();

        // RINGS (playerSpeed != obstacleSpeed)
        this.rings = [];
        for(let i=0;i<this.ringCount;i++){
          const r = this.baseR + i*this.gapR;
          const base = 0.58 + i*0.08;
          const sign = (i%2===0?1:-1);

          const playerSpeed   = sign * base * 0.92;
          const obstacleSpeed = sign * base * 1.10;

          this.rings.push(this.makeRing(r, playerSpeed, obstacleSpeed, i));
        }

        // START
        this.playerRingIndex = this.ringCount - 1;
        this.playerAngle = -2.35;
        this.state = "READY"; // READY | ORBIT | JUMP | GAMEOVER

        this.activeJump = null; // { ..., closestChord }

        // BONUS POPUP helper (shows +2 PERFECT)
        this.showBonus = (x, y, text) => {
          const t = this.add.text(x, y, text, {
            fontFamily:"system-ui,-apple-system,Segoe UI,Roboto,Arial",
            fontSize:"22px",
            color:"#ffd166",
            fontStyle:"900"
          }).setOrigin(0.5);

          this.tweens.add({
            targets: t,
            y: y - 26,
            alpha: 0,
            duration: 320,
            ease: "Cubic.easeOut",
            onComplete: () => t.destroy()
          });
        };

        this.applyTheme();
        this.redraw();
        this.placePlayer(true);

        // INPUT
        this.input.on("pointerdown", ()=>this.tap());
        this.input.keyboard.on("keydown-SPACE", ()=>this.tap());
        this.input.keyboard.on("keydown-R", ()=>this.scene.restart());

        // GAME OVER
        this.gameOverText = this.add.text(w/2, h/2, "", {
          fontFamily:"system-ui,-apple-system,Segoe UI,Roboto,Arial",
          fontSize:"30px", color:"#fff", align:"center", fontStyle:"900"
        }).setOrigin(0.5).setVisible(false);

        // Resize => restart
        window.addEventListener("resize", ()=>{
          this.scale.resize(document.getElementById("game").clientWidth, document.getElementById("game").clientHeight);
          this.scene.restart();
        });
      }

      makeRing(radius, playerSpeed, obstacleSpeed, idx){
        const ring = { idx, r: radius, playerSpeed, obstacleSpeed, obstacles: [] };
        this.spawnObstaclesForRing(ring);
        return ring;
      }

      spawnObstaclesForRing(ring){
        for(const ob of ring.obstacles){ ob.sprite.destroy(); }
        ring.obstacles = [];

        // 3,4,5. halkalarda 2 top (idx 2,3,4)
        const specialTwoOpposite = (ring.idx === 2 || ring.idx === 3 || ring.idx === 4);

        let count;
        if(specialTwoOpposite){
          count = 2;
        } else {
          const t = (ring.r - this.baseR) / (this.gapR*(this.ringCount-1)); // 0..1
          count = Math.round(lerp(1, 3, t));
          if (t < 0.15) count = 1;
        }

        // inner boost: inner faster
        const innerT = 1 - (ring.idx / (this.ringCount - 1)); // 1 inner -> 0 outer
        const innerBoost = 1 + 0.55 * innerT;                 // inner ~1.55x

        for(let k=0;k<count;k++){
          let a = Math.random()*Math.PI*2;

          for(let tries=0;tries<12;tries++){
            let ok = true;
            for(const other of ring.obstacles){
              const d = Phaser.Math.Angle.Wrap(a - other.angle);
              if(Math.abs(d) < 0.80){ ok=false; break; }
            }
            if(ok) break;
            a = Math.random()*Math.PI*2;
          }

          const dot = this.add.circle(0,0, this.obstacleRadius, 0xff3b30, 1);

          let spd = ring.obstacleSpeed * innerBoost;
          if(specialTwoOpposite){
            spd = (k === 0) ? (ring.obstacleSpeed * innerBoost) : (-ring.obstacleSpeed * innerBoost);
          }

          ring.obstacles.push({ angle: a, sprite: dot, speed: spd });
        }
      }

      applyTheme(){
        const hue = (220 + this.themeStep*18) % 360;
        const ringHue = (hue + 25) % 360;
        const [br,bg,bb] = hslToRgb(hue, 0.86, 0.26);
        const [rr,rg,rb] = hslToRgb(ringHue, 0.92, 0.56);

        this.bgColor = rgbToInt(br,bg,bb);
        this.ringColor = rgbToInt(rr,rg,rb);

        this.bgRect.fillColor = this.bgColor;
      }

      redraw(){
        const w = this.scale.width, h = this.scale.height;
        this.gfx.clear();

        // starfield
        this.gfx.fillStyle(0xffffff, 0.03);
        for(let i=0;i<140;i++){
          const x = (i*79)%w;
          const y = (i*151)%h;
          this.gfx.fillCircle(x,y,(i%3===0)?1.3:1.0);
        }

        // rings
        for(let i=0;i<this.rings.length;i++){
          const ring = this.rings[i];
          const alpha = 0.14 + i*0.05;
          const thickness = (i === this.rings.length-1) ? 12 : 8;

          this.gfx.lineStyle(thickness+10, this.ringColor, alpha*0.10);
          this.gfx.strokeCircle(this.cx, this.cy, ring.r);

          this.gfx.lineStyle(thickness, this.ringColor, alpha);
          this.gfx.strokeCircle(this.cx, this.cy, ring.r);
        }

        this.updateObstaclePositions();
      }

      updateObstaclePositions(){
        for(const ring of this.rings){
          for(const ob of ring.obstacles){
            ob.sprite.x = this.cx + ring.r*Math.cos(ob.angle);
            ob.sprite.y = this.cy + ring.r*Math.sin(ob.angle);
          }
        }
      }

      placePlayer(init=false){
        const ring = this.rings[this.playerRingIndex];
        const x = this.cx + ring.r*Math.cos(this.playerAngle);
        const y = this.cy + ring.r*Math.sin(this.playerAngle);
        this.player.setPosition(x,y);
        this.playerHalo.setPosition(x,y);
        this.playerCore.setPosition(x,y);
        if (init) return;
      }

      tap(){
        if(this.state === "GAMEOVER"){ this.scene.restart(); return; }

        if(this.state === "READY"){
          this.state = "ORBIT";
          this.tweens.add({ targets:this.hint, alpha:0, duration:240, onComplete:()=>this.hint.setVisible(false) });
        }
        if(this.state !== "ORBIT") return;

        const next = this.playerRingIndex - 1;
        if(next < 0) return;

        this.state = "JUMP";

        const fromRing = this.rings[this.playerRingIndex];
        const toRing   = this.rings[next];
        const angle    = this.playerAngle;

        const rNow = Math.hypot(this.player.x - this.cx, this.player.y - this.cy);

        this.activeJump = {
          fromRing,
          toRing,
          angle,
          prevR: rNow,
          crossed: false,
          closestChord: Infinity, // <-- for PERFECT proximity
          hit: false,
          done: false,
          nextIndex: next
        };

        const tweenObj = { t:0 };
        this.tweens.add({
          targets:tweenObj,
          t:1,
          duration:this.jumpDuration,
          ease:"Sine.easeInOut",
          onUpdate:()=>{
            const r = Phaser.Math.Linear(fromRing.r, toRing.r, tweenObj.t);
            const x = this.cx + r*Math.cos(angle);
            const y = this.cy + r*Math.sin(angle);

            this.player.setPosition(x,y);
            this.playerHalo.setPosition(x,y);
            this.playerCore.setPosition(x,y);
          },
          onComplete:()=>{
            if(this.activeJump) this.activeJump.done = true;
          }
        });
      }

      finalizeJump(){
        const aj = this.activeJump;
        this.activeJump = null;

        if(!aj) return;
        if(aj.hit){ this.die(); return; }

        this.playerRingIndex = aj.nextIndex;

        // PERFECT = "çarpmadı ama çok yakın geçti"
        const thresh = this.playerRadius + this.obstacleRadius + this.collisionPad;
        const perfect = (aj.closestChord !== Infinity &&
                         aj.closestChord >  thresh &&
                         aj.closestChord <= (thresh + this.perfectNearHi) &&
                         aj.closestChord >= (thresh + this.perfectNearLo));

        if(perfect){
          this.score += 2;
          this.showBonus(this.player.x, this.player.y - 18, "+2 PERFECT");
        } else {
          this.score += 1;
        }

        this.scoreText.setText("Score: " + this.score);

        // best score update
        if(this.score > this.bestScore){
          this.bestScore = this.score;
          sessionStorage.setItem("jo_best_score", String(this.bestScore));
          this.bestText.setText("BEST  " + this.bestScore);

          // tiny "ping" feel without changing anything else
          this.tweens.add({
            targets: this.bestText,
            scaleX: 1.08,
            scaleY: 1.08,
            yoyo: true,
            duration: 120,
            ease: "Sine.easeOut"
          });
        }

        if(this.playerRingIndex === 0){
          this.shiftRingsInward();
        }

        this.state = "ORBIT";
      }

      shiftRingsInward(){
        this.themeStep++;
        this.applyTheme();

        const removed = this.rings.pop();
        for(const ob of removed.obstacles){ ob.sprite.destroy(); }

        const currentInner = this.rings[0].r;
        const newInnerR = Math.max(24, currentInner - this.gapR);

        const baseNew = 0.55;
        const dir = (this.themeStep % 2 === 0) ? 1 : -1;

        const newPlayerSpeed   = dir * baseNew * 0.92;
        const newObstacleSpeed = dir * baseNew * 1.10;

        const newRing = this.makeRing(newInnerR, newPlayerSpeed, newObstacleSpeed, 0);
        this.rings.unshift(newRing);

        for(let i=0;i<this.rings.length;i++){
          const ring = this.rings[i];
          ring.idx = i;
          ring.r = this.baseR + i*this.gapR;

          const speedBoost = 1 + Math.min(0.45, this.themeStep*0.03);
          const base = 0.58 + i*0.08;
          const sign = (i%2===0?1:-1);

          ring.playerSpeed   = sign * base * speedBoost * 0.92;
          ring.obstacleSpeed = sign * base * speedBoost * 1.10;
        }

        for(const ring of this.rings) this.spawnObstaclesForRing(ring);

        this.playerRingIndex = this.rings.length - 1;
        this.placePlayer(true);

        this.redraw();
      }

      die(){
        // best update on death too
        if(this.score > this.bestScore){
          this.bestScore = this.score;
          sessionStorage.setItem("jo_best_score", String(this.bestScore));
          this.bestText.setText("BEST  " + this.bestScore);
        }

        this.state = "GAMEOVER";
        this.activeJump = null;

        const boom = this.add.circle(this.player.x, this.player.y, 10, 0xffffff, 0.85);
        this.tweens.add({
          targets:boom,
          radius: 80,
          alpha: 0,
          duration: 300,
          ease:"Sine.easeOut",
          onComplete:()=>boom.destroy()
        });

        this.player.setVisible(false);
        this.playerHalo.setVisible(false);
        this.playerCore.setVisible(false);

        this.gameOverText.setText(`Game Over\nScore: ${this.score}\nBest: ${this.bestScore}\n\nClick / R to restart`);
        this.gameOverText.setVisible(true);
      }

      update(time, delta){
        const dt = delta/1000;

        // rotate obstacles with their own speed
        for(const ring of this.rings){
          for(const ob of ring.obstacles){
            ob.angle = Phaser.Math.Angle.Wrap(ob.angle + ob.speed*dt);
          }
        }
        this.updateObstaclePositions();

        // JUMP collision at ring crossing
        if(this.state === "JUMP" && this.activeJump && !this.activeJump.hit){
          const aj = this.activeJump;
          const rNow = Math.hypot(this.player.x - this.cx, this.player.y - this.cy);

          const prevDist = aj.prevR - aj.toRing.r;
          const currDist = rNow - aj.toRing.r;

          if(!aj.crossed && prevDist > 0 && currDist <= 0){
            aj.crossed = true;

            const R = aj.toRing.r;
            const thresh = this.playerRadius + this.obstacleRadius + this.collisionPad;

            for(const ob of aj.toRing.obstacles){
              const d = Phaser.Math.Angle.Wrap(aj.angle - ob.angle);
              const ad = Math.abs(d);

              const chord = 2 * R * Math.sin(ad / 2);

              // closest approach (for PERFECT proximity)
              if(chord < aj.closestChord) aj.closestChord = chord;

              // actual collision
              if(chord <= thresh){
                aj.hit = true;
                break;
              }
            }
          }

          aj.prevR = rNow;
        }

        // finalize jump
        if(this.state === "JUMP" && this.activeJump && this.activeJump.done){
          this.finalizeJump();
        }

        // ORBIT: rotate player + same ring collision
        if(this.state === "ORBIT"){
          const ring = this.rings[this.playerRingIndex];
          this.playerAngle = Phaser.Math.Angle.Wrap(this.playerAngle + ring.playerSpeed*dt);
          this.placePlayer();

          const R = ring.r;
          const thresh = this.playerRadius + this.obstacleRadius + this.collisionPad;

          for(const ob of ring.obstacles){
            const d = Phaser.Math.Angle.Wrap(this.playerAngle - ob.angle);
            const ad = Math.abs(d);
            const chord = 2 * R * Math.sin(ad / 2);
            if(chord <= thresh){
              this.die();
              break;
            }
          }
        }

        // halo pulse
        if(this.state !== "GAMEOVER"){
          this.playerHalo.setAlpha(0.10 + 0.04*Math.sin(time/180));
        }
      }
    }

    const parent = document.getElementById("game");
    new Phaser.Game({
      type: Phaser.AUTO,
      parent: "game",
      width: parent.clientWidth,
      height: parent.clientHeight,
      backgroundColor: "#061a66",
      scene: [FlowScene],
      scale: { mode: Phaser.Scale.NONE }
    });
  </script>
</body>
</html>